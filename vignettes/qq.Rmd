---
title: "The QQ plot"
author: "Manuel Gimond"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
    css: style.css
vignette: >
  %\VignetteIndexEntry{The QQ plot}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#> ",
  message = FALSE,
  tidy = FALSE,
  cache = FALSE,
  warning = FALSE,
  encoding = "UTF-8"
)
```

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev.args=list(pointsize=10))
```

# Introduction

The *empirical quantile-quantile plot* (QQ plot) is probably one of the most underused and least appreciated plots in univariate analysis. It is used to compare two distributions across their *full* range of values. It is a generalization of the boxplot in that it does not limit the comparison to just the median and upper and lower quartiles. In fact, it compares *all* values by matching each value in one batch to its corresponding quantile in the other batch. The sizes of each batch need not be the same. If they differ, the larger batch is interpolated down to the smaller batch's set of quantiles.

A QQ plot can not only help visualize the differences in distributions, but it can also model the relationship between both batches. Note that this is not to be confused with modeling the relationship between a bivariate dataset where the latter pairs up the points by *observational units* whereas a QQ plot pairs up the values by their "matching quantiles".


# Anatomy of the `eda_qq` plot

```{r  fig.width=3, fig.height=3, echo = FALSE}
library(tukeyedar)
set.seed(897)
x <- rnorm(30)
y <- x * 1.5 + 1 + rnorm(30, 0, 0.1 )
eda_qq(x,y)
```

* Each "dot" represents matching quantiles from each batch. 
* The *shaded boxes* represent each batch's interquartile ranges (mid 50% of values).
* The *Solid dashed lines* inside the shaded boxes represent each batch's medians.
* The *lightly shaded dashed dots* represent each batch's 12.5^th^ and 87.5^th^ quantiles (i.e. they show the ends of the mid 80% of values).
* The *upper right-hand text* indicates the power transformation applied to the both batches (default is a power of `1` which is original measurement scale). If a formula is applied to one or both batches, it too will appear in the upper right-hand text.
* The `eda_qq` will also output the *suggested relationship* between the y variable and the x variable. It bases this on each batch's interquartile values.

# An overview of some of the function arguments

## Data type
The function will accept a *dataframe* with a values column and a group column, or it will accept *two separate vector objects*. For example, to pass two separate vector object, `x` and `y`, type:

```{r fig.height = 3, fig.width = 3, results='hide'}
library(tukeyedar)
set.seed(207)
x <- rnorm(30)
y <- rnorm(30) + 0.5
eda_qq(x, y)
```

If the data are in a dataframe, type:

```{r fig.height=3, fig.width = 3, results='hide'}
dat <- data.frame(val = c(x, y), cat = rep(c("x", "y"), each = 30))
eda_qq(dat, val, cat)
```

## Suppressing plot

You can suppress the plot and have the x and y values outputted to a list. If the batches did not match in size, the output will show their interpolated values such that the output batches match in size.

The output will also include the power parameter applied to both batches as well as any formula applied to one or both batches (`fx` is the formula applied to the x variable and `fy` is the formula applied to the y variable).

```{r}
out <- eda_qq(x,y, plot = FALSE)
out
```

## Setting the grey box and dashed line parameters

The grey box highlights the interquartile ranges for both batches. Its boundary can be modified via the `b.val` argument. Likewise, the lightly shaded dashed dots that highlight the mid 80% of values can be modified via the `l.val` argument. 

For example, to highlight the mid 68% of values using the grey boxes and the mid 95% of values using the lightly shaded dashed dots, type:

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(x, y, b.val = c(0.16, 0.84), l.val = c(0.025, 0.975))
```

You can suppress the plotting of the grey box and the lightly shaded dashed dots by setting `q = FALSE`. This does not affect the median dashed lines.

## Applying a formula to one of the batches

You can apply a formula to a batch via the `fx` argument for the x-variable and the `fy` argument for the y-variable.  The formula is passed as a text string. For example, to add `0.5` to the x values, type:

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(x, y, fx = "x + 0.5")
```

## Quantile type

There are many different quantile algorithms available in R. To see the full list of quantile types, refer to the quantile help page: `?quantile`. By default, `eda_qq()` adopts `q.type = 5`.  In general, the choice of quantiles will not really matter, especially for large datasets. If you want to adopt R's default type, set `q.type = 7`.

## Point symbols

The point symbol type, color and size can be modified via the `pch`, `p.col` (and/or `p-fill`) and `size` arguments. The color can be either a built-in color name (you can see the full list by typing `colors()`) or the `rgb()` function. If you define the color using one of the built-in color names, you can adjust its transparency via the    `alpha` argument. A value of `0` renders the point completely transparent and a value of `1` renders the point completely opaque. The point symbol can take on two color parameters depending on point type. If `pch` is any number between 21 and 25, `p.fill` will define its fill color and `p.col` will define its border color. For any other point symbol type, the `p.fill` argument is ignored.

Here are a few examples:

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(x, y, p.fill = "bisque", p.col = "red", size = 1.2)
```

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(x, y, pch = 16, p.col = "tomato2", size = 1.5, alpha = 0.5)
```

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(x, y, pch = 3, p.col = "tomato2", size = 1.5)
```

# Interpreting a QQ plot

To help interpret the following QQ plots, we'll compare each plot to matching kernel density plots. We'll start with a simple example

```{r fig.height=3, fig.width = 6, echo=2:7, results='hide'}
OP <- par(mfrow=c(1,2))
library(tukeyedar)
set.seed(543)
x <- rnorm(100)
y <- x + 2
eda_qq(x, y)
eda_dens(x,y)
par(OP)
```

```{r fig.height=3, fig.width = 6, echo=2:4, results='hide'}
OP <- par(mfrow=c(1,2))
y <- x * 0.5
eda_qq(x,y)
eda_dens(x,y)
par(OP)
```

```{r fig.height=3, fig.width = 6, echo=2:4, results='hide'}
OP <- par(mfrow=c(1,2))
y <- x * 0.5 + 2
eda_qq(x,y)
eda_dens(x,y)
par(OP)
```


```{r fig.height=3, fig.width = 6, echo=2:6, results='hide'}
OP <- par(mfrow=c(1,2))
set.seed(540)
x2 <- rbeta(100, 1,8)
y2 <- x2 + 0.2 
eda_qq(x2,y2)
eda_dens(x2,y2)
par(OP)
```

# Power transformation

```{r}
s1 <- subset(Indometh, Subject == 1, select = conc, drop = TRUE)
s2 <- subset(Indometh, Subject == 2, select = conc, drop = TRUE)
```

```{r  fig.width=3, fig.height=3, results='hide'}
eda_qq(s1, s2, p = 1)
eda_qq(s1, s2, p = 0)
eda_qq(s1,s2,p=0,fx="x * 0.8501 + 0.3902")
```

```{r fig.height=3, fig.width = 3, results='hide'}
eda_dens(s1, s2)
```

## The Tukey mean-difference plot

This is simply an extension of the QQ plot whereby the plot is rotated such that the 45&deg; line (the 1:1 slope) becomes horizontal. This can be useful in helping identify subtle differences between batches. The plot is rotated 45&deg; by mapping the difference between both batches to the y-axis, and mapping the mean between both batches to the x-axis. For example, the following figure on the left (the QQ plot) shows the additive offset between both batches but it fails to show the multiplicative offset. The latter can be clearly seen in the Tukey mean-difference plot (on the right) which can be invoked by setting the argument `md = TRUE`.

```{r fig.height=3, fig.width = 6, echo=2:4, results='hide'}
OP <- par(mfrow=c(1,2))
y <- x * 0.97 + 0.3
eda_qq(x,y)
eda_qq(x,y, md = TRUE)
par(OP)
```

## A working example

```{r fig.height=3, fig.width=3, results='hide'}
old <- wat95$avg # legacy temperature normals
new <- wat05$avg # current temperature normals
out <- eda_qq(old, new)
```


```{r fig.height=3, fig.width=3, results='hide'}
old <- wat95$avg # legacy temperature normals
new <- wat05$avg # current temperature normals
out <- eda_qq(old, new, md = TRUE)
```


```{r fig.height=3, fig.width = 9, eval=FALSE}
labs <- c("low", "mid", "high")
out$avg <- (out$x + out$y) / 2
out <- as.data.frame(out[c(1:2,6)])
out2 <- split(out, cut(out$avg, c(min(out$avg), 35, 50, max(out$avg)), 
                       labels = labs, include.lowest = TRUE))
sapply(labs, FUN = \(x) {eda_qq(out2[[x]]$x, out2[[x]]$y ,
                                xlab = "old", ylab = "new", md = T)
                         title(x, line = 3, col.main = "orange")} )
```

```{r fig.height=3, fig.width = 9, echo=FALSE, results='hold', dev.args=list(pointsize=14)}
OP <- par(mfrow = c(1,3))
labs <- c("low", "mid", "high")
out$avg <- (out$x + out$y) / 2
out <- as.data.frame(out[c(1:2,6)])
out2 <- split(out, cut(out$avg, c(min(out$avg), 35, 50, max(out$avg)), labels = labs, include.lowest = TRUE))
tmp <- sapply(labs, FUN = \(x) {eda_qq(out2[[x]]$x, out2[[x]]$y ,
                                       xlab = "old", ylab = "new", md = T)
                                title(x, line = 3, col.main = "orange")} )
par(OP)
```


What not to do:
```{r fig.height=3, fig.width = 9, echo=2:5, results='hide', dev.args=list(pointsize=14)}
OP <- par(mfrow = c(1,3))
labs <- c("low", "mid", "high")
old.split <- split(old, cut(old, c(min(old), 35, 50, max(old)), 
                            labels = labs, include.lowest = TRUE))
new.split <- split(new, cut(new, c(min(new), 35, 50, max(new)), 
                            labels = labs, include.lowest = TRUE))
sapply(labs, FUN = \(x) {eda_qq(old.split[[x]], new.split[[x]] ,
                                xlab = "old", ylab = "new", md = T)
                         title(x, line = 3, col.main = "orange")} )
par(OP)
```


```{r fig.height=3, fig.width = 9, echo=2:4, results='hide', dev.args=list(pointsize=14)}
OP <- par(mfrow = c(1,3))
xform <- c("x * 0.9636 + 1.4411", 
           "x * 0.9838 + 0.7478",
           "x * 1.0365 - 2.0333")
names(xform) <- labs
sapply(labs, FUN = \(x) {eda_qq(old.split[[x]], new.split[[x]] , 
                                fx = xform[x],
                                xlab = "old", ylab = "new", md = T); 
                         title(x, line = 3, col.main = "orange")} )
par(OP)
```


The characterization of the differences in normal temperatures between the old and new set of normals can be formalized as follows: 

$$
new = \begin{cases}
old * 0.9636 + 1.4411, &  T_{avg} < 35 \\
old * 0.9838 + 0.7478, & 35 \le T_{avg} < 50  \\
old * 1.0365 - 2.0333, & T_{avg} \ge 50
\end{cases}
$$


The key takeaways from this analysis can be summarized as follows:

* 

